---
params:
  site: "https://steffilazerte.ca/workshop-dealing-with-data"
  answers: "visible" #"hidden"
format: 
  revealjs:
    title: Loading & Cleaning Data in R
    subtitle: I know the file exists, why doesn't R?
    title-slide-attributes: 
      data-background-image: figures/dataset.png
      data-background-size: "40%"
      data-background-position: "95% 50%"
---

```{r setup}
#| include: false
#| cache: false

visibility <- params$answers
site <- params$site

library(palmerpenguins)
library(tidyverse)
library(glue)
library(skimr)
source("0_figs.R")

options(tibble.print_max = 10, tibble.print_min = 10, width = 200)
```

# First things first

:::{style="text-align:left; padding: 15px 200px 15px 200px"}
{{< fa floppy-disk >}} Save previous script

{{< fa folder-open >}} Open New File <br>
[(make sure you're in the RStudio Project)]{.small .hang}

{{< fa pen >}} Write `library(tidyverse)` at the top

{{< fa floppy-disk >}} Save this new script <br>
[(consider names like `cleaning.R` or `3_loading_and_cleaning.R`)]{.small .hang}
:::

## Download the data we'll use in this workshop

1. Create a '**data**' folder in your RStudio project
    - In the "Files" pane click on the folder icon **OR**
    - Navigate to your project folder via your computer's file browser
    
![Click on "New Folder"](figures/files.png){fig-alt="Screenshot of the file viewer pane in RStudio with \"New Folder\" circled in red" width=30%}


[ ]{style="margin-top:10px;"}

2. Right-click "Save Link As.." and download these files to your **data** folder

::::{.columns}
:::{.column}
- [ðŸ”—`water_cleaned.xlsx`](`r glue("{site}/data/water_cleaned.xlsx")`)
- [ðŸ”—`water_raw.csv`](`r glue("{site}/data/water_raw.csv")`)
- [ðŸ”—`master_moch.txt`](`r glue("{site}/data/master_moch.txt")`)
- [ðŸ”—`geolocators.csv`](`r glue("{site}/data/geolocators.csv")`)
:::
:::{.column}
- [ðŸ”—`grain_size.txt`](`r glue("{site}/data/grain_size.txt")`)
- [ðŸ”—`grain_size2.csv`](`r glue("{site}/data/grain_size2.csv")`)
- [ðŸ”—`grain_meta.csv`](`r glue("{site}/data/grain_meta.csv")`)
- [ðŸ”—`Sta A Data 2006-11-07.dmp`](`r glue("{site}/data/Sta%20A%20Data%202006-11-07.dmp")`)
:::
::::

# Side Note
*R base vs. `tidyverse`*

## R base vs. `tidyverse`

### R base
- Basic R
- Packages are installed and loaded by default
- Base pipe `|>` *

![](figures/logo_r.png){.absolute right=20% top=10% width=20% fig-alt="RStudio blue ball logo"}

[*We'll cover pipes soon `r emo::ji("grin")`]{.footnote}

:::{.fragment}
### `tidyverse`
- Collection of 'new' packages developed by a team closely affiliated with RStudio
  - e.g., `ggplot2`, `dplyr`, `tidyr`, `readr`
  - Packages designed to work well together
- Use a slightly different syntax
- tidyverse pipe `%>%` or base pipe `|>` *

![](figures/hex_tidyverse.png){.absolute right=40% bottom=0 width=15% fig-alt="Hex logo for the tidyverse R package"}
:::

[Useful to know if functions are<br>**`tidyverse`** or **R base**]{.fragment .note .absolute bottom=5% left=80% width=25%}


## Dealing with data

::::{.columns}
:::{.column width=50%}

### 1. Loading data
  - Get your data into R

### 2. Looking for problems
  - Typos
  - Incorrectly loaded data

### 3. Fixing problems
  - Corrections
  - Renaming
  - Dealing with NA's
:::

:::{.column width=50%}
### 4. Setting formats
  - Text, 
  - Numbers
  - Factors
  - Dates

### 5. Saving your data
:::
::::


# Loading Data


## Data types: What kind of data do you have?

### Specific program files

::::{.columns}
:::{.column width=80%}

Type           | Extension         | R Package   | R function
-------------- | ----------------- | ----------- | ------------
Excel          | .xls, .xlsx       | `readxl`*    | `read_excel()` 
Open Document  | .ods              | `readODS`   | `read_ods()`
SPSS           | .sav, .zsav, .por | `haven`     | `read_spss()`
SAS            | .sas7bdat         | `haven`     | `read_sas()`            
Stata          | .dta              | `haven`     | `read_dta()`
Database Files | .dbf              | `foreign`   | `read.dbf()`
:::
::::

:::{.fragment}
### Convenient but...
- Can be unreliable
- Can take longer
:::

[For files that don't change, better to save as a `*.csv`<br>
(Comma-separated-variables file)
]{.fragment .note .absolute bottom=0 left=60%}

![](figures/hex_readxl.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the readxl R package"}
[* part of the `tidyverse`]{.footnote}


## Data types: What kind of data do you have?

### General text files

Type            | R base          | `readr` package *
--------------- | --------------- | --------------
Comma separated | `read.csv()`    | `read_csv()`, `read_csv2()`
Tab separated   | `read.delim()`  | `read_tsv()`
Space separated | `read.table()`  | `read_table()`
Fixed-width     | `read.fwf()`    | `read_fwf()`

![](figures/hex_readr.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the readr R package"}
[* part of the `tidyverse`]{.footnote}

:::{.fragment .spacer}
- **`readr` package** especially useful for big data sets (fast!)
- Error/warnings from `readr` are a bit more helpful
:::


:::{.fragment .note .absolute width=50% bottom=-15%}
[**We'll focus on**]{.large}

- `readxl` package {{< fa arrow-right >}} `read_excel()`    
- `readr` package {{< fa arrow-right >}} `read_csv()`, `read_tsv()`  
:::


## Where is my data?

### Common error

```{r, error = TRUE}
my_data <- read_csv("weather.csv")
```

With no folder (just file name) R expects file to be in **Working directory**

:::{.fragment .spacer}
### Working directory is:
- Where your RStudio project is
- Your home directory (My Documents, etc.) [If not using RStudio Projects]
- Where you've set it (using `setwd()` or RStudio's Session > Set Working Directory)
:::

:::{.fragment .note .absolute bottom=-5% width=50%}
**Don't** use `setwd()`  
**Do** use Projects in RStudio  
:::


## Where is my data?

### A note on file paths (file locations)


```{r eval = FALSE}
/home
```

- folders separated by `/`
- `home` is a folder


## Where is my data?

### A note on file paths (file locations)


```{r eval = FALSE}
/home/steffi/
```

- folders separated by `/`
- `home` and `steffi` are folders
- `steffi` is a folder inside of `home`


## Where is my data?

### A note on file paths (file locations)

```{r eval = FALSE}
/home/steffi/Documents/R Projects/mydata.csv
```

- folders separated by `/`
- `home`, `steffi`, `Documents`, `R Projects` are folders
- `steffi` is inside of `home`, `Documents` is inside of `steffi`, etc.
- `mydata.csv` is a data file inside `R Projects` folder


![RStudio Files Pane](figures/file_viewer.png){width=40% fig-alt="Screenshot of RStudio file pane showing mydata.csv"}


## Where is my data?

### **Absolute** Paths
:::{.small .left}
OS     | Path
------ | -----------------------
**LINUX** | /home/steffi/Documents/R Projects/mydata.csv
 **WINDOWS** | C:/Users/steffi/My Documents/R Projects/mydata.csv
**MAC** | /users/steffi/Documents/R Projects/mydata.csv
:::

:::{.fragment .note .absolute top=28% left=75%}
Full location, folders and filename
:::

:::{.fragment}
### **Relative** Paths {.spacer}
:::{.small .left}
Path               | Where to look
------------------ | ---------------------------------------------------
mydata.csv         | Here (current directory)
../mydata.csv      | Go up one directory (../)
data/mydata.csv    | Stay here, go into "data" folder (data/)
../data/mydata.csv | Go up one directory (../), then into "data" folder (data/)
:::
:::

:::{.fragment .note .absolute top=65% left=75%}
Only *relative* info  
Use relative symbols (e.g., `../`)
:::

:::{.note .fragment .absolute bottom=-5% left=25%}
With RStudio 'Projects' only need to use **relative** paths
:::


## Keep yourself organized

### For simple projects
- Create an 'RStudio Project' for each Project <!--(Chapter, Thesis, etc.) -->
- Create a specific "data" folder within each project (one per project)

```{r eval = FALSE}
#| code-line-numbers: "1,3"
- Prospect Lake Quality                 # Project Folder
    - prospect_analysis.R
    - data                              # Data Folder   
        - prospect_data_2017-01-01.csv
        - prospect_data_2017-02-01.csv
```

:::{.fragment}

- Use **relative** paths to refer to this folder

```{r, eval = FALSE}
d <- read_csv("data/prospect_data_2017-01-01.csv")
```

:::


# Let's load some data!

## A reminder about Assignments!

- `<-`
- "Assign" an object to a handle/name

```{r eval = FALSE}
my_figure <- ggplot(data = penguins, aes(x = body_mass_g, y = bill_length_mm)) +
    geom_point()

my_data <- read_csv("my_data_spreadsheet.csv")
```

- `my_figure` is an R object, specifically a ggplot2 figure
- `my_data` is an R object, specifically a data.frame 

> To *use* your data, you need to load it *and* assign it to a handle/name


## Your turn: Load some data  {.space-list}
**Working with [ðŸ”—`water_cleaned.xlsx`](`r glue("{site}/data/water_cleaned.xlsx")`)**

::::{.columns}
:::{.column width=60%}

1. Load the package
```{r, message = FALSE}
library(readxl)
```
2. Read in the Excel file  and assign to object `water`
```{r, message = FALSE}
water <- read_excel("data/water_cleaned.xlsx")
```
3. Use `head()` and `tail()` functions to look at the data   
  [e.g., `head(water)` and `tail(water)`]{.hang .small}

4. Click on the `water` object in your "Environment" pane to look at the whole data set
:::

:::{.column width=40%}
![Use the *'tab'* key in RStudio when typing in the file name for auto-complete](figures/tip_file_nav.gif){fig-alt="GIF showing the dropdown menu that appears when you hit the 'tab' key inside the quotes when typing file locations"}
:::

::::



## Your turn: Load some data {visibility=`r visibility`}

:::{.small}
```{r, message = FALSE}
library(readxl)
water <- read_excel("data/water_cleaned.xlsx")
```
```{r}
head(water)
tail(water)
```
:::

![](figures/dataset.png){.absolute right=0 top=0 width=45% fig-alt="Screenshot of the data shown in the RStudio viewer pane"}


## How do I know which function to use? {.space-list}

### Program-specific files
- Files which only normally open in a particular program (e.g., Excel)
- **Load with function from specific package (e.g. `read_excel` from readxl package)**

### Text files
- Files which open in notepad
- Files which open in RStudio when you click on them in the Files Pane
- **Load with function from readr package (e.g. `read_csv()`, `read_tsv()`, etc.)**

### Look at the file extension:
- [ðŸ”—`water_cleaned.xlsx`](`r glue("{site}/data/water_cleaned.xlsx")`) {{< fa arrow-right >}} Excel file {{< fa arrow-right >}} `read_excel()`
- [ðŸ”—`water_raw.csv`](`r glue("{site}/data/water_raw.csv")`) {{< fa arrow-right >}} Comma-separated-variables {{< fa arrow-right >}} `read_csv()`

[But sometimes not clear...]{.note .absolute .fragment left=80% bottom=10% width=30%}

## How do I know which function to use? {.space-list}

### Working with: [ðŸ”—`master_moch.txt`](`r glue("{site}/data/master_moch.txt")`)
    
- In lower right-hand pane, click on **Files**
- Click on **data** folder
- Click on **master_moch.txt**
- Click "View File" [(if asked)]{.small}


```{r echo = FALSE}
cat(readChar("data/master_moch.txt", nchars = 214))
```


[This **does not** read the file into R, but only shows you the contents as text.
]{.note .absolute bottom=8%}


[Hmm, not comma-separated, maybe tab-separated?]{.note .fragment .absolute bottom=-5% width=60%}

## How do I know which function to use?

### Peak:
- Pick a read function with your best guess (`read_csv()` is a good start)
- Use `n_max` to read only first few rows

```{r, message = FALSE}
read_csv("data/master_moch.txt", n_max = 3)
```

:::{.spacer}
[`\t` means tab, so this is tab-separated data]{.note}
:::

## How do I know what to use?

### Peak:
- Try again with `read_tsv()`


```{r, message = FALSE}
read_tsv("data/master_moch.txt", n_max = 3)  # note change in function!
```

::::{.spacer}
[Excellent!]{.note}
:::

# Specifics of loading functions


## `col_names`  {.space-list}

**Working with [ðŸ”—`geolocators.csv`](`r glue("{site}/data/geolocators.csv")`)**

<p>

::::{.columns}
:::{.column width=60%}

```{r}
my_data <- read_csv("data/geolocators.csv")
my_data
```
Oops?
:::

:::{.column .fragment width=40%}
- `read_csv`, `read_tsv`, etc. assume that the first row contains the column names
- This file doesn't have headers
:::

::::



## `col_names`

**Working with [ðŸ”—`geolocators.csv`](`r glue("{site}/data/geolocators.csv")`)**

<p>

::::{.columns}
:::{.column width=48%}

### Declare no headings
```{r}
#| code-line-numbers: "2"
my_data <- read_csv("data/geolocators.csv", 
                    col_names = FALSE)
my_data
```

:::

:::{.column width=52%}
:::{.fragment}
### Name headings

```{r}
#| code-line-numbers: "2"
my_data <- read_csv("data/geolocators.csv", 
                    col_names = c("date", "light"))
my_data
```
:::
:::
::::


## `skip` info rows before data

**Working with [ðŸ”—`grain_size.txt`](`r glue("{site}/data/grain_size.txt")`)**

```{r, error = TRUE, message = FALSE, highlight.output = c(2, 4:6)}
my_data <- read_tsv("data/grain_size.txt")
my_data
```



## `skip` info rows before data

**Working with [ðŸ”—`grain_size.txt`](`r glue("{site}/data/grain_size.txt")`)**


```{r, eval = FALSE}
my_data <- read_tsv("data/grain_size.txt")
my_data
```

::::{.columns}
:::{.column width=30%}
**Look at the file:**

- Click on **Files** tab
- Click on **data** folder
- Click on **grain_size.txt**
- Click **"View file"** [(if asked)]{.small}

:::

:::{.column width=60% .fragment}
```{r, echo = FALSE}
cat(readChar("data/grain_size.txt", nchars = 320))
```
:::
::::

[**Ah ha!**<br>Metadata was stored at the top of the file
]{.note .absolute .fragment bottom=10% left=50%}


## `skip` info rows before data

**Working with [ðŸ”—`grain_size.txt`](`r glue("{site}/data/grain_size.txt")`)**

- Add `skip = 3` to skip the first three rows

```{r, message = FALSE}
my_data <- read_tsv("data/grain_size.txt", skip = 3)
my_data
```

[Much better!]{.note .absolute bottom=40% left=65%}


## Your turn: Load this data set

**Load Data: [ðŸ”—`Sta A Data 2006-11-07.dmp`](`r glue("{site}/data/Sta%20A%20Data%202006-11-07.dmp")`)**

1. Look at the file
2. Decide which R function to use based on delimiter [(comma, space, or tab?)]{.small}
3. Any other options need to be specified?

### It should look like this:
```{r yt_load, echo = FALSE, message = FALSE, R.options = list(tibble.print_max = 7, tibble.print_min = 7)}
telemetry <- read_csv("data/Sta A Data 2006-11-07.dmp", skip = 2)
telemetry
```

[**Too Easy?**<br>Load some of your own tricky data]{.note .absolute bottom=17% left=80% width=40%}
[**OR**<br>Try to load the second sheet of `water_cleaned.xlsx`]{.note .absolute bottom=0 left=70% width=60%}



## Your turn: Load this data set {visibility=`r visibility`}

**Load Data: [ðŸ”—`Sta A Data 2006-11-07.dmp`](`r glue("{site}/data/Sta%20A%20Data%202006-11-07.dmp")`)**

```{r, ref.label="yt_load", message = FALSE, R.options = list(tibble.print_max = 7, tibble.print_min = 7)}
```


## Your turn: Load this data set {visibility=`r visibility`}

**Too Easy?**

- Use `sheet` argument to access specific sheet [(`excel_sheets()` lists them all)]{.small}
- skip the first *two* rows (including the headers)

```{r}
excel_sheets("data/water_cleaned.xlsx")  # Or look yourself ;)

water2 <- read_excel("data/water_cleaned.xlsx", sheet = "Oswegatchie", skip = 2)
water2
```


# Looking for problems

## Look at the data

- Make sure columns as expected [(correctly assigned file format)]{.small}
- Make sure no extra lines above the data [(should we have used a skip?)]{.small}
- Make sure column names look appropriate

```{r}
library(palmerpenguins)
penguins
```


## Look at the data

- Did the whole data set load?
- Are there extra blank lines at the end of the data?

```{r}
tail(penguins)
```



## `skim()` the data

### `skim()` is from `skimr` {.spacer}

::::{.columns}
:::{.column .small .space-list width=25%}
- Are the formats correct?
  - numbers (`numeric`), 
  - text (`character`)
  - date (`date`, `POSIXct`, `datetime`)
  - categories (`factor`)
- Are values appropriate? 
  - Should there be `NA`s?
- Are there any typos?
- Number of rows expected?
:::

:::{ .small .column width=75%}
```{r, render = knitr::normal_print}
library(skimr)
skim(penguins)
```
:::
::::

![](figures/hex_skimr.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the skimr R package"}


## `count()` categories


### `count()` is from `dplyr`* {.spacer}

- Check for sample sizes and potential typos in categorical columns
- Assess missing values

::::{.columns}
:::{.column}
```{r}
count(penguins, species)
count(penguins, island)
```
:::
:::{.column}
```{r}
count(penguins, sex)
```
:::
::::


![](figures/hex_dplyr.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the dplyr R package"}
[* part of the `tidyverse`]{.footnote}

## Plot categories


:::{.spacer}
```{r}
#| eval: false
# Replace COLUMN with the column name to explore
ggplot(data = penguins, aes(x = COLUMN)) + 
  geom_bar()
```
:::

::::{.columns style="font-size: 75%"}
:::{.column width=33%}
```{r}
#| fig-asp: 1
#| fig-width: 4
#| echo: false
ggplot(data = penguins, aes(x = species)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_bar() +
  labs(title = "x = species")
```
:::

:::{.column width=33%}
```{r}
#| fig-asp: 1
#| fig-width: 4
#| echo: false
ggplot(data = penguins, aes(x = island)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_bar() +
  labs(title = "x = island")
```
:::

:::{.column width=33%}
```{r}
#| fig-asp: 1
#| fig-width: 4
#| echo: false
ggplot(data = penguins, aes(x = sex)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_bar()+
  labs(title = "x = sex")
```
:::

::::


![](figures/hex_ggplot2.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the ggplot2 R package"}
[* part of the `tidyverse`]{.footnote}

## Plot numbers

:::{.spacer}
```{r}
#| eval: false
# Replace COLUMN with the column name to explore
ggplot(data = penguins, aes(x = COLUMN)) + 
  geom_histogram()
```
:::

:::{style="font-size: 75%"}
```{r}
#| fig-asp: 0.5
#| fig-width: 10
#| out-width: 80%
#| fig-align: center
#| echo: false
library(patchwork)
g1 <- ggplot(data = penguins, aes(x = bill_length_mm)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_histogram() +
  labs(title = "x = bill_length_mm")

g2 <- ggplot(data = penguins, aes(x = bill_depth_mm)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_histogram() +
  labs(title = "x = bill_depth_mm")

g3 <- ggplot(data = penguins, aes(x = flipper_length_mm)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_histogram() +
  labs(title = "x = flipper_length_mm")

g4 <- ggplot(data = penguins, aes(x = body_mass_g)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_histogram() +
  labs(title = "x = body_mass_g")

(g1 + g3) / (g2 + g4) + theme(plot.margin = unit(c(0,0,0,0), "mm"))

```
:::


![](figures/hex_ggplot2.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the ggplot2 R package"}
[* part of the `tidyverse`]{.footnote}



# Example of problematic data


## Look at the data

**Working with: [ðŸ”—`water_raw.csv`](`r glue("{site}/data/water_raw.csv")`)**

```{r, message = FALSE}
water <- read_csv("data/water_raw.csv")
water
```


- Column names are not R-friendly (`River Name` and `Temperature CÂ°`) 
  or obvious (what is `Ele`?)
- At least one typo in River (`Grase` should be `Grasse`)


## Looking for problems

### Your Turn!


```{r, message = FALSE}
water <- read_csv("data/water_raw.csv")
water
```

- `skim()` the data
- `count()` some columns
- Perhaps make some `ggplot()`s

[Find any problems?]{.note .absolute bottom=10% left=70%}


## `skim()` the data {visibility=`r visibility`}
```{r, render = knitr::normal_print}
#| R.options:
#|   width: 110
library(skimr)
skim(water)
```

## `count()` categories {visibility=`r visibility`}

::::{.columns}
:::{.column}
```{r}
count(water, `River Name`)
count(water, Wea)
```
:::

:::{.column}
```{r}
count(water, Site)
count(water, Ele)
```
:::
::::


## Plot categories {visibility=`r visibility`}


:::{.spacer}
```{r}
#| eval: false
# Replace COLUMN with the column name to explore
ggplot(data = water, aes(x = COLUMN)) + 
  geom_bar()
```
:::

:::{style="font-size: 75%"}
```{r}
#| fig-asp: 0.5
#| fig-width: 12
#| out-width: 90%
#| fig-align: center
#| echo: false
g1 <- ggplot(data = water, aes(x = `River Name`)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_bar() +
  labs(title = "x = `River Name`")

g2 <- ggplot(data = water, aes(x = Site)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_bar() +
  labs(title = "x = Site")

g3 <- ggplot(data = water, aes(x = Wea)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_bar()+
  labs(title = "x = Wea")

g4 <- ggplot(data = water, aes(x = Ele)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_bar()+
  labs(title = "x = Ele")

(g1 + g2) / (g3 + g4) + theme(plot.margin = unit(c(0,0,0,0), "mm"))
```
:::


## Plot numbers {visibility=`r visibility`}

:::{.spacer}
```{r}
#| eval: false
# Replace COLUMN with the column name to explore
ggplot(data = water, aes(x = COLUMN)) + 
  geom_histogram()()
```
:::

:::{style="font-size: 75%"}
```{r}
#| fig-asp: 0.45
#| fig-width: 10
#| out-width: 100%
#| fig-align: center
#| echo: false
library(patchwork)
g1 <- ggplot(data = water, aes(x = Amo)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_histogram() +
  labs(title = "x = Amo")

g2 <- ggplot(data = water, aes(x = `Temperature CÂ°`)) + 
  theme(plot.title = element_text(family = "mono")) +
  geom_histogram() +
  labs(title = "x = `Temperature CÂ°`")

g1 + g2 + theme(plot.margin = unit(c(0,0,0,0), "mm"))

```
:::



# Fixing problems


## Cleaning column names

### `clean_names()` is from `janitor`* {.spacer}

[* *not* part of the `tidyverse` but `tidyverse`-orientated]{.footnote}


```{r, message = FALSE}
#| class-output: small
library(janitor)
water <- clean_names(water)
water
```

![](figures/hex_janitor.png){width=10% .absolute top=0 right=0 fig-alt="Hex logo for the janitor R package"}
<!-- ![](figures/horst_janitor.png){width=57% .absolute top=20% right=-5%} -->

## Side Note: Naming conventions

![](figures/horst_case1.png){fig-align="center" fig-alt="Cartoon representations of common cases in coding. A snake screams \"SCREAMING_SNAKE_CASE\" into the face of a camel (wearing ear muffs) with \"camelCase\" written along its back. Vegetables on a skewer spell out \"kebab-case\" (words on a skewer). A mellow, happy looking snake has text \"snake_case\" along it."}

## Side Note: Naming conventions

![](figures/horst_case2.png){fig-align="center" fig-alt="Joke, totally made up failed programming cases. ducklingcasE (all lowercase, represented as small ducklings, until the last letter as the mama duck). BatCase (written upside down, on a bat cartoon). SH__K_CASE (shark case - screaming snake but with big chunks taken out -- a shark is below chomping on the missing AR. Lobster case: snake_case but backwards, written on a lobster carapace moving in reverse."}



## Cleaning column names

### `rename()` is from `dplyr`* {.spacer}

**`rename()` columns**

```{r}
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water
```

![](figures/hex_dplyr.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the dplyr R package"}
[* part of the `tidyverse`]{.footnote}

## Subsetting columns

### `select()` is from `dplyr`* {.spacer}

**`select()` columns you want **

```{r, eval = FALSE}
water <- select(water, river_name, site, element, amount)
```

![](figures/hex_dplyr.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the dplyr R package"}
[* part of the `tidyverse`]{.footnote}


:::{.fragment}
**OR, un`select()` columns you don't want**
```{r}
water <- select(water, -wea)
water
```
:::



## Cleaning columns

### Put it all together

```{r, message = FALSE}
water <- read_csv("data/water_raw.csv")
water <- clean_names(water)
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water <- select(water, -wea)
water
```

[Note how code repeats data frame `water`...]{.note .fragment .absolute bottom=0}


## Fixing typos

Remember the typos...

```{r}
count(water, river_name)
```
## Fixing typos

### Replace typos
Combine the `if_else` function with the `mutate()` function

```{r}
water <- mutate(water, river_name = if_else(river_name == "Grase", "Grasse", river_name))
```

### Check that it's gone:
```{r}
count(water, river_name)
```

## Fixing typos

### `if_else()` and `mutate()` from `dplyr` package* {.spacer}


:::{.spacer}
**`mutate()`** creates or changes columns in a data frame:

```{r, eval = FALSE}
mutate(dataframe, column = new_values)
```
:::

:::{.spacer}
**`if_else()`** tests for a condition, and returns one value if `FALSE` and another if `TRUE`

```{r, eval = FALSE}
if_else(condition, value_if_true, value_if_false)
```

:::

![](figures/hex_dplyr.png){width=15% .absolute top=0 right=0 fig-alt="Hex logo for the dplyr R package"}
[* part of the `tidyverse`]{.footnote}


## Iterative process

- Make some corrections
- Check the data
- Make some more corrections (either add to or modify existing code)


:::{.fragment}

### Many corrections?

[**Try `case_when()` from `dplyr` package* **]{.spacer}

:::{.spacer}
**`case_when()`** tests for multiple conditions, and returns different values depending
```{r, eval = FALSE}
case_when(condition1 ~ value_if_true1,
          condition2 ~ value_if_true2,
          condition3 ~ value_if_true3,
          TRUE ~ default_value)
```
:::

![](figures/hex_dplyr.png){width=15% .absolute top=0 right=0 fig-alt="Hex logo for the dplyr R package"}
[* part of the `tidyverse`]{.footnote}
:::

## Your Turn: Fix another "Grasse" typo

1. Check the data with `count()`
2. Use `mutate()` and `if_else()` to fix the typo

```{r, eval = FALSE}
#| code-line-numbers: "7"
water <- read_csv("data/water_raw.csv")
water <- clean_names(water)
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water <- select(water, -wea)
water <- mutate(water, river_name = if_else(river_name == "Grase", "Grasse", river_name))

water <- mutate(???, ??? = ???)
```

[**Too Easy?**<br>Examine and fix problems in your own data]{.note .absolute bottom=20% left=50%}
[**OR**<br>Use `case_when()` to fix all the river name typos at once...]{.note .absolute bottom=0 left=50% width=60%}



## Your Turn: Fix another "Grasse" typo {visibility=`r visibility`}

1. Check the data with `count()`
2. Use `mutate()` and `if_else()` to fix the typo

```{r, eval = FALSE}
#| code-line-numbers: "7"
water <- read_csv("data/water_raw.csv")
water <- clean_names(water)
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water <- select(water, -wea)
water <- mutate(water, river_name = if_else(river_name == "Grase", "Grasse", river_name))

water <- mutate(water, river_name = if_else(river_name == "grasse", "Grasse", river_name))
```


## Fixing typos  {visibility=`r visibility`}

### To be more efficient, fix all typos at once

```{r, message = FALSE}
#| code-line-numbers: "5,6"
water <- read_csv("data/water_raw.csv")
water <- clean_names(water)
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water <- select(water, -wea)
water <- mutate(water, 
                 river_name = if_else(river_name %in% c("Grase", "grasse"), "Grasse", river_name))
```


[`==` compares one item to one other<br>`%in%` 
compares one item to many different ones]{.note .absolute bottom=30%}


## Fixing typos  {visibility=`r visibility`}

### One last typo to fix
```{r}
#| code-line-numbers: "7"
water <- read_csv("data/water_raw.csv")
water <- clean_names(water)
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water <- select(water, -wea)
water <- mutate(water, 
                 river_name = if_else(river_name %in% c("Grase","grasse"), "Grasse", river_name),
                 river_name = if_else(river_name == "raquette", "Raquette", river_name))
```

:::{.fragment}

### Combine with `case_when()`
```{r}
#| code-line-numbers: "6-8"
water <- read_csv("data/water_raw.csv")
water <- clean_names(water)
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water <- select(water, -wea)
water <- mutate(water, 
                 river_name = case_when(river_name %in% c("Grase", "grasse") ~ "Grasse",
                                        river_name == "raquette" ~ "Raquette",
                                        TRUE ~ river_name))
```
:::



# Tangent: `tidyverse` functions

## `tidyverse` functions

### `rename()`, `select()`, `mutate()`
- `tidyverse` functions always start with the **data**, followed by other arguments
- you can reference any **column** from '**data**'

```{r}
water <- read_csv("data/water_raw.csv")
water <- clean_names(water)
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water <- select(water, -wea)
water <- mutate(water, river_name = if_else(river_name %in% c("Grase", "grasse"), "Grasse",  river_name))
```

- `rename()` changes column names
- `select()` chooses columns to keep or to remove (with `-`)
- `mutate()` changes column contents

![](figures/hex_tidyverse.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the tidyverse R package"}

## Why use `tidyverse` functions?

### Pipes! `|>`* Allow you to string commands together

Instead of:
```{r}
water <- read_csv("data/water_raw.csv")
water <- clean_names(water)
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water <- select(water, -wea)
water <- mutate(water, 
                 river_name = case_when(river_name %in% c("Grase", "grasse") ~ "Grasse",
                                        river_name == "raquette" ~ "Raquette",
                                        TRUE ~ river_name))
```
         

[* `|>` is the base pipe, `%>%` is the tidyverse pipe, you can use either]{.footnote}

![](figures/hex_tidyverse.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the tidyverse R package"}

:::{.fragment}

We have:

```{r, message = FALSE}
water <- read_csv("data/water_raw.csv") |>
  clean_names() |>
  rename(element = ele, amount = amo, temperature = temperature_c) |>
  select(-wea) |>
  mutate(river_name = case_when(river_name %in% c("Grase", "grasse") ~ "Grasse",
                                river_name == "raquette" ~ "Raquette",
                                TRUE ~ river_name))
```

:::

## Play around

Take a moment to play with this code in your console

### Convert this:
```{r}
water <- read_csv("data/water_raw.csv")
water <- clean_names(water)
water <- rename(water, element = ele, amount = amo, temperature = temperature_c)
water <- select(water, -wea)
water <- mutate(water, 
                 river_name = case_when(river_name %in% c("Grase", "grasse") ~ "Grasse",
                                        river_name == "raquette" ~ "Raquette",
                                        TRUE ~ river_name))
```


### To this:

```{r, message = FALSE}
water <- read_csv("data/water_raw.csv") |>
  clean_names() |>
  rename(element = ele, amount = amo, temperature = temperature_c) |>
  select(-wea) |>
  mutate(river_name = case_when(river_name %in% c("Grase", "grasse") ~ "Grasse",
                                river_name == "raquette" ~ "Raquette",
                                TRUE ~ river_name))
```


![](figures/hex_tidyverse.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the tidyverse R package"}

# Dealing with `NA`s
[Data that *is* missing<br>Data that *should* be missing]{.large}


## Exploring `NA`s

- We saw missing values in `amount`
- Use `filter()` to take a closer look

```{r}
filter(water, is.na(amount))
```

## Omitting `NA`s

### `drop_na()` is from `tidyr`* {.spacer}


:::{.spacer}
Omit `NA`s from the `amount` column only (drop those rows)
```{r}
water_no_na <- drop_na(water, amount)
```

Omit **all** `NA`s from **all** columns (drop those rows)
```{r}
water_no_na <- drop_na(water)
```
:::

:::{.fragment .spacer}
Check...
```{r}
filter(water_no_na, is.na(amount))
nrow(water_no_na)
```

[No more `NA`s!<br>Fewer rows]{.note .absolute bottom=-10%}
:::

[* part of the `tidyverse`]{.footnote}
![](figures/hex_tidyr.png){width=20% .absolute top=0 right=0 fig-alt="Hex logo for the tidyr R package"}

## Side Note: `filter()` also omits `NA`s `r emo::ji("scream")`

If we filter by the column with `NA`s, they are silently dropped

:::{.small}
```{r}
filter(water, amount < 0.05)
```
:::

:::{.small}
We need to be explicit if we want to keep them
```{r}
filter(water, amount < 0.05 | is.na(amount))
```
:::



## Replacing `NA`s

### `replace_na()` is from `tidyr`* {.spacer}

```{r}
water_no_na <- mutate(water, amount = replace_na(amount, 0))
```

:::{.fragment .spacer}
Check...
```{r}
filter(water_no_na, is.na(amount))
nrow(water_no_na)
```

[No more `NA`s!<br>Same number of rows]{.note .absolute bottom=25%}
:::


:::{.fragment .small .spacer}
(If you want to do a more complex replacement, you'll have to use `if_else()` or
`case_when()` like we did for typos.)
:::

[* part of the `tidyverse`]{.footnote}
![](figures/hex_tidyr.png){width=20% .absolute top=0 right=0 fig-alt="Hex logo for the tidyr R package"}

## Converting *to* `NA`


Remember the problem with `temperature`?

```{r}
filter(water, temperature < -10)
```

:::{.fragment}
### `na_if()` is from `dplyr`*   {.spacer}

```{r}
water <- mutate(water, temperature = na_if(temperature, -99))
```

![](figures/hex_dplyr.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the dplyr R package"}
[* part of the `tidyverse`]{.footnote}
:::

:::{.fragment}
Check...
```{r}
filter(water, is.na(temperature))
```
:::




# Fixing formats

## Fixing formats

::::{.columns}
:::{.column width=40%}
### Basic data types
- Text (Characters or Strings)
- Numbers (Doubles, Integers)
- Logical (TRUE or FALSE)
- Factor (Categories)
- Dates
- Date/Times
:::
:::{.column .fragment width=60%}

### Look for problems

```{r, highlight.output = 3}
water
```

[Year could be categorical (factor)<br>Better for plotting!<br>[(although it really depends)]{.small}]{.note .absolute left=70% bottom=-5% width=40%}
:::
::::

## Convert to categorical

```{r}
water <- mutate(water, year = as.factor(year))
water
```

## Changing classes

Function  |  Input | Output
--------- | -------------- | ------
`as.character()` |  Any vector | Text (Characters)
`as.numeric()`   |  Any vector (but returns NAs if not numbers) | Numbers
`as.logical()`   |  TRUE, FALSE, T, F, 1, 0 (FALSE), any other number (all TRUE) | TRUE or FALSE
`as.factor()`    |  Any vector | Categories


[We'll deal with dates and times later...]{.note .absolute bottom=20%}



## Put it all together...

```{r}
water <- read_csv("data/water_raw.csv") |>
  clean_names() |>
  rename(element = ele, amount = amo, temperature = temperature_c) |>
  select(-wea) |>
  mutate(river_name = case_when(river_name %in% c("Grase", "grasse") ~ "Grasse",
                                river_name == "raquette" ~ "Raquette",
                                TRUE ~ river_name),
         amount = replace_na(amount, 0),
         temperature = na_if(temperature, -99),
         year = as.factor(year)) 
```



### And you have a clean, corrected data frame ready to use {.spacer}
- You have not changed the original data
- You have a **reproducible** record of all corrections
- You can alter these corrections at any time
- You have formatted your data for use in R
- Read these steps line by line to remind yourself what you did

## Put it all together...

### Feel free to annotate within a pipe
```{r}
water <- read_csv("data/water_raw.csv") |>
  # Fix column names
  clean_names() |>
  rename(element = ele, amount = amo, temperature = temperature_c) |>
  select(-wea) |>
  mutate(
    # Correct typos
    river_name = case_when(river_name %in% c("Grase", "grasse") ~ "Grasse",
                           river_name == "raquette" ~ "Raquette",
                           TRUE ~ river_name),
    # Missing amounts should be 0
    amount = replace_na(amount, 0),
    # Problems with temperature logger, -99 is a mistake
    temperature = na_if(temperature, -99),
    # Convert for plotting 
    year = as.factor(year)) 
```


# Dates and Times

[**(Or why does R hate me?)**]{.large}


## Dates and Times

**Working with [ðŸ”—`geolocators.csv`](`r glue("{site}/data/geolocators.csv")`)**

- Date/times aren't always recognized as date/times


```{r, message = FALSE, R.options = list(tibble.print_max = 6, tibble.print_min = 6)}
geolocators <- read_csv("data/geolocators.csv", col_names = c("time", "light"))
geolocators
```

> Here `time` column is considered `chr` (character/text)  
>
> **You** may know it's a date, but R does not


## {data-menu-title="lubridate" background-image="figures/horst_lubridate_ymd.png" background-size=75% background-position="top" title="Fuzzy cartoon monsters in construction hats sorting a pile of \"Y\" \"M\" and \"D\" into separate piles labeled \"Years\", \"Months\" and \"Days\". Title text reads \"Lubridate: wrangle times and dates!\""}

[Artwork by [@allison_horst](https://github.com/allisonhorst/stats-illustrations)]{.footnote}


## `lubridate` package*

- Part of `tidyverse`, but needs to be loaded separately
- Great for converting date/times [(i.e. telling R this is a date/time)]{.small}

```{r message = FALSE, R.options = list(tibble.print_max = 6, tibble.print_min = 6)}
library(lubridate)
geolocators <- mutate(geolocators, time_fixed = dmy_hms(time))
geolocators
```

> Now `time_fixed` column is considered `dttm` (Date/Time)
>
> So **You** know it's a Date/Time and now **R** knows too


![](figures/hex_lubridate.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the lubridate R package"}
[* part of the `tidyverse`]{.footnote}

## `lubridate` package*


![](figures/hex_lubridate.png){width=16% .absolute top=0 right=0 fig-alt="Hex logo for the lubridate R package"}

Generally, only the order of the **y**ear, **m**onth, **d**ay, **h**our, **m**inute, or **s**econd matters.

**For example**

:::{.spacer}
date/time format       | function    | output class
---------------------- | ----------- | -------
2018-01-01 13:09:11    | `ymd_hms()` | dttm (POSIXct/POSIXt)
12/20/2019 10:00 PM    | `mdy_hm()` | dttm (POSIXct/POSIXt)
31/01/2000 10 AM       | `dmy_h()` | dttm (POSIXct/POSIXt)
31-01/2000             | `dmy()` | Date
:::

:::{.spacer}
> `lubridate` is smart enough to detect AMs and PMs
:::

[**Note:** R *generally* requires that times have dates (`datetime`/`POSIXct`), 
but dates don't have to have times (`Date`)<br>
* part of the `tidyverse`]{.footnote}


# Saving data

[For the love of all that is good don't *lose* that data!!!*]{.large}

[* but if you've been paying attention, you know that you only need the script `r emo::ji("wink")`]{.small style="color:grey;display:block;margin-top:60px"}

## Saving data

### Keep yourself organized
- Keep your R-created data in a **different** folder from your 'raw' data*
- If you have a lot going on, split your work into several scripts, and number the both the scripts AND the data sets produced:
 - `1_cleaned.csv`
 - `2_summarized.csv`
 - `3_graphing.csv`

:::{.fragment}
### Save your data to file:

- First create the *datasets* folder 

```{r, eval = FALSE}
write_csv(water, "datasets/water_cleaned.csv")
```
![](figures/hex_readr.png){width=16% .absolute bottom=12% right=0 fig-alt="Hex logo for the readr R package"}
:::

[* I usually have a `data` folder and then both `raw` and `datasets` folders inside of that]{.footnote}




## Dealing with data

::::{.columns}
:::{.column width=50%}
### 1. Loading data
  - Get your data into R

### 2. Looking for problems
  - Typos
  - Incorrectly loaded data

### 3. Fixing problems
  - Corrections
  - Renaming
  - Dealing with NA's
:::

:::{.column width=50%}
### 4. Setting formats
  - Text
  - Numbers
  - Factors
  - Dates

### 5. Saving your data
:::
::::



## Wrapping up: Common mistakes

### Assuming your data is in one format when it's not
- Print your data to the console and use `skim()` to explore the format of your data
- Use `skim()`, `count()`, `filter()`, `select()`, `ggplot()` to explore the content of your data


## Wrapping up: Common mistakes
### Confusing pipes with function arguments
- Pipes (`|>` or `%>%`) pass the _output_ from one function as _input_ (first argument) to the next function

```{r, eval = FALSE}
my_data <- my_data |>                 # Pass my_data
  filter(my_column > 5) |>            # Pass my_data, filtered
  select(my_column, my_second_column)
```

- Arguments may be on different lines, but all part of _one_ function
```{r, eval = FALSE}
my_data <- my_data |>                  # Pass my_data
  mutate(my_column1 = if_else(...),    # No passing (no pipes!)
         my_column2 = if_else(...),    # Instead, give 3 arguments to mutate:
         my_column3 = if_else(...))    # Arguments separated by ",", and surrounded by ( )

```





## Wrapping up: Further reading

- R for Data Science
  - [Chapter 3: Data transformation](https://r4ds.hadley.nz/data-transform.html)
  - [Chapter 6: Workflow: scripts and projects](https://r4ds.hadley.nz/workflow-scripts.html)
  - [Chapter 14: Strings](https://r4ds.hadley.nz/strings.html)
  - [Chapter 16: Factors](https://r4ds.hadley.nz/factors.html)
  - [Chapter 4.3: Workflow: code style > Pipes](https://r4ds.hadley.nz/workflow-style.html#sec-pipes)
  
  
